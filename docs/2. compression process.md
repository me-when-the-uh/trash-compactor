# Compression Execution

The execution phase transforms the compression plan—a list of file paths and their assigned algorithms—into on-disk changes. This process is orchestrated by the `compress_directory` function in `src/compression_module.py`, which hands off the finalized plan to the execution engine.

## Orchestration

The `execute_compression_plan` function in `src/compression/compression_executor.py` serves as the entry point for this phase. It accepts the plan and a set of worker constraints. Instead of processing files strictly in order, it groups them by algorithm (XPRESS4K, XPRESS8K, XPRESS16K, LZX). This grouping allows the program to optimize resource usage by applying different concurrency limits to different algorithms.

## Batch Processing

To minimize the overhead of process creation, the executor processes files in batches rather than individually. The `_chunk` helper function divides the file list for a given algorithm into manageable groups. A batch is formed when it reaches either 100 files (`_BATCH_SIZE`) or when the combined command-line length approaches the 4000-character limit (`_MAX_COMMAND_CHARS`) imposed by Windows.

For each batch, the `_compact_batch` function constructs a single command line for the Windows Compact utility. It generates a command in the format `compact /c /a /exe:<algorithm> <file1> <file2> ...`. This command is executed via `subprocess.run`, with the console window hidden to prevent UI flashing.

## Verification and Fallback

After a batch completes, the program confirms whether or not a file has been compressed successfully. The `_finalize_success` function delegates this check to `is_file_compressed` in `src/file_utils.py`.

This function uses the Windows API `GetCompressedFileSizeW` (accessed via `ctypes`) to retrieve the actual on-disk size. It compares this against the logical file size obtained from `Path.stat()`. If the on-disk size is smaller, the compression is deemed successful.

If a batch operation fails (indicated by a non-zero exit code from `compact.exe`) or if an exception occurs, the program assumes that one or more files in the batch caused the issue. It then degrades gracefully by calling `_compress_single` for every file in that failed batch. This function attempts to compress files one by one, isolating failures to specific files while allowing the rest to proceed.

## Legacy Branding

The program also supports a maintenance mode for "branding" files—marking them as compressed in the filesystem metadata without re-compressing the data. This is handled by `compress_directory_legacy` in `src/compression_module.py`.

It uses `legacy_compress_file` in `src/compression/compression_executor.py` to run a simplified `compact /c <file>` command. Unlike the main execution pipeline, this mode does not use batching, as it is intended for targeted fixes rather than bulk processing.
